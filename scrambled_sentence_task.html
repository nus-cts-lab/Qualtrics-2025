<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrambled Sentence Task</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .cognitive-load {
            text-align: center;
            font-size: 48px;
            font-weight: bold;
            padding: 50px;
            background: white;
            border: 3px solid #333;
            margin: 50px auto;
            max-width: 300px;
        }
        
        .black-screen {
            background: black;
            height: 100vh;
            width: 100vw;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1000;
        }
        
        .timer {
            font-size: 24px;
            font-weight: bold;
            color: #d00;
            text-align: center;
            margin-bottom: 20px;
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 100;
        }
        
        .sentence-item {
            margin: 30px 0;
            padding: 20px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: #fafafa;
        }
        
        .sentence-number {
            font-weight: bold;
            font-size: 18px;
            color: #333;
            margin-bottom: 15px;
        }
        
        .words-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .word-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        
        .word-text {
            font-size: 16px;
            font-weight: bold;
            flex-grow: 1;
        }
        
        .word-input {
            width: 40px;
            padding: 5px;
            text-align: center;
            border: 1px solid #999;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .instructions {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 30px;
            font-size: 16px;
            line-height: 1.6;
        }
        
        .digit-input {
            text-align: center;
            margin: 30px 0;
        }
        
        .digit-input input {
            width: 200px;
            padding: 10px;
            font-size: 18px;
            text-align: center;
            border: 2px solid #333;
            border-radius: 5px;
        }
        
        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        
        .btn:hover {
            background: #0056b3;
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .hidden {
            display: none;
        }
        
        .progress {
            background: #e0e0e0;
            height: 10px;
            border-radius: 5px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: #28a745;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="cognitive-load-screen" class="hidden">
        <div class="cognitive-load" id="digit-display"></div>
    </div>
    
    <div id="black-screen" class="black-screen hidden"></div>
    
    <div id="main-task" class="container hidden">
        <div class="timer" id="timer">Time: 4:00</div>
        
        <div class="instructions">
            <strong>Instructions:</strong> Unscramble each sentence to form whatever statement comes to mind first. 
            Enter numbers 1-5 in the boxes next to the words to indicate the order of your sentence. 
            Use exactly 5 words for each sentence. Complete as quickly as possible.
            <br><br>
            <strong>Remember:</strong> Keep the 6-digit number in your memory throughout this task.
        </div>
        
        <div class="progress">
            <div class="progress-bar" id="progress-bar" style="width: 0%"></div>
        </div>
        
        <div id="sentences-container"></div>
        
        <button class="btn" id="submit-btn" onclick="completeTrial()">Submit Responses</button>
    </div>
    
    <div id="digit-recall" class="container hidden">
        <h2>Memory Check</h2>
        <p>Please enter the 6-digit number you were asked to remember:</p>
        <div class="digit-input">
            <input type="text" id="recalled-digits" maxlength="6" placeholder="Enter 6 digits">
        </div>
        <button class="btn" onclick="completeTask()">Finish Task</button>
    </div>
    
    <div id="completion" class="container hidden">
        <h2>Task Complete</h2>
        <p>Thank you for completing the scrambled sentence task!</p>
        <div id="results"></div>
    </div>

    <script>
        // Sentence stimuli based on the provided lists
        const sentences = [
            ['life', 'is', 'good', 'cruel', 'to', 'me'],
            ['i', 'am', 'equal', 'inferior', 'to', 'others'],
            ['i', 'want', 'to', 'keep', 'stop', 'trying'],
            ['my', 'life', 'is', 'generally', 'interesting', 'boring'],
            ['i', 'expect', 'to', 'be', 'happy', 'miserable'],
            ['the', 'future', 'looks', 'very', 'bright', 'dismal'],
            ['i', 'usually', 'feel', 'very', 'good', 'bad'],
            ['i', 'remember', 'regret', 'what', 'i', 'done'],
            ['something', 'nothing', 'is', 'wrong', 'with', 'me'],
            ['i', 'am', 'a', 'worthwhile', 'worthless', 'person'],
            ['i', 'have', 'succeeded', 'failed', 'at', 'life'],
            ['life', 'has', 'not', 'been', 'bad', 'good'],
            ['i', 'like', 'dislike', 'who', 'i', 'am'],
            ['people', 'do', 'not', 'care', 'about', 'me'],
            ['i', 'have', 'something', 'nothing', 'to', 'give'],
            ['i', 'am', 'generally', 'a', 'success', 'failure'],
            ['my', 'life', 'is', 'very', 'interesting', 'stressful'],
            ['my', 'personal', 'relationships', 'are', 'satisfying', 'disappointing'],
            ['i', 'am', 'confident', 'disappointed', 'in', 'myself'],
            ['life', 'is', 'well', 'not', 'worth', 'living']
        ];
        
        let currentDigits = '';
        let startTime = 0;
        let timerInterval = null;
        let currentSentenceIndex = 0;
        let responses = [];
        
        // Valence coding dictionaries
        const positiveWords = [
            'good', 'equal', 'keep', 'interesting', 'happy', 'bright', 'worthwhile', 'succeeded',
            'satisfying', 'confident', 'well', 'worth', 'nice', 'approve', 'winner', 'form', 
            'sensible', 'right', 'talents', 'enjoy', 'attend', 'relax', 'sleep'
        ];
        
        const negativeWords = [
            'cruel', 'inferior', 'stop', 'boring', 'miserable', 'dismal', 'worthless', 'failed',
            'disappointing', 'disappointed', 'not', 'bad', 'dislike', 'dont', 'struggle', 'avoid',
            'cry', 'edge', 'foolish', 'wrong', 'mistakes', 'endure', 'upset', 'tense', 'worry',
            'worrier', 'disapprove', 'regret', 'nothing', 'stressful'
        ];
        
        function generateRandomDigits() {
            return Math.floor(100000 + Math.random() * 900000).toString();
        }
        
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
        
        function analyzeValence(sentence) {
            if (!sentence || sentence.trim() === '') return 'incomplete';
            
            const words = sentence.toLowerCase().split(' ').map(word => word.trim());
            let positiveCount = 0;
            let negativeCount = 0;
            
            words.forEach(word => {
                if (positiveWords.includes(word)) positiveCount++;
                if (negativeWords.includes(word)) negativeCount++;
            });
            
            // Return valence based on which words were chosen
            if (positiveCount > negativeCount) return 'positive';
            if (negativeCount > positiveCount) return 'negative';
            if (positiveCount === negativeCount && positiveCount > 0) return 'mixed';
            return 'neutral';
        }
        
        function calculateValenceScores(responses) {
            let positiveCount = 0;
            let negativeCount = 0;
            let neutralCount = 0;
            let mixedCount = 0;
            let incompleteCount = 0;
            let completedSentences = 0;
            
            const valenceResults = responses.map((response, index) => {
                const valence = analyzeValence(response.finalSentence);
                
                if (response.words.length === 5) {
                    completedSentences++;
                    switch(valence) {
                        case 'positive': positiveCount++; break;
                        case 'negative': negativeCount++; break;
                        case 'neutral': neutralCount++; break;
                        case 'mixed': mixedCount++; break;
                        case 'incomplete': incompleteCount++; break;
                    }
                } else {
                    incompleteCount++;
                }
                
                return {
                    sentence: index + 1,
                    response: response.finalSentence || 'INCOMPLETE',
                    valence: valence,
                    completed: response.words.length === 5
                };
            });
            
            const valenceRatio = completedSentences > 0 ? (positiveCount / completedSentences) : 0;
            const negativityRatio = completedSentences > 0 ? (negativeCount / completedSentences) : 0;
            
            return {
                valenceResults: valenceResults,
                summary: {
                    completedSentences: completedSentences,
                    positiveCount: positiveCount,
                    negativeCount: negativeCount,
                    neutralCount: neutralCount,
                    mixedCount: mixedCount,
                    incompleteCount: incompleteCount,
                    valenceRatio: Math.round(valenceRatio * 100) / 100,
                    negativityRatio: Math.round(negativityRatio * 100) / 100
                }
            };
        }
        
        function showCognitiveLoad() {
            currentDigits = generateRandomDigits();
            document.getElementById('digit-display').textContent = currentDigits;
            document.getElementById('cognitive-load-screen').classList.remove('hidden');
            
            setTimeout(() => {
                document.getElementById('cognitive-load-screen').classList.add('hidden');
                document.getElementById('black-screen').classList.remove('hidden');
                
                setTimeout(() => {
                    document.getElementById('black-screen').classList.add('hidden');
                    startMainTask();
                }, 10000); // 10 second black screen
            }, 5000); // 5 second digit display
        }
        
        function startMainTask() {
            document.getElementById('main-task').classList.remove('hidden');
            createSentenceItems();
            startTimer();
        }
        
        function createSentenceItems() {
            const container = document.getElementById('sentences-container');
            container.innerHTML = '';
            
            for (let i = 0; i < 20; i++) {
                const sentenceWords = sentences[i % sentences.length];
                const scrambledWords = shuffleArray(sentenceWords);
                
                const sentenceDiv = document.createElement('div');
                sentenceDiv.className = 'sentence-item';
                sentenceDiv.innerHTML = `
                    <div class="sentence-number">Sentence ${i + 1}</div>
                    <div class="words-container" id="sentence-${i}">
                        ${scrambledWords.map((word, index) => `
                            <div class="word-item">
                                <span class="word-text">${word}</span>
                                <input type="number" class="word-input" min="1" max="5" 
                                       data-sentence="${i}" data-word="${word}" data-position="${index}"
                                       onchange="updateProgress()">
                            </div>
                        `).join('')}
                    </div>
                `;
                container.appendChild(sentenceDiv);
            }
        }
        
        function startTimer() {
            startTime = Date.now();
            const duration = 4 * 60 * 1000; // 4 minutes in milliseconds
            
            timerInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const remaining = duration - elapsed;
                
                if (remaining <= 0) {
                    clearInterval(timerInterval);
                    document.getElementById('timer').textContent = 'Time: 0:00';
                    completeTrial();
                    return;
                }
                
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                document.getElementById('timer').textContent = 
                    `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }
        
        function updateProgress() {
            const inputs = document.querySelectorAll('.word-input');
            let completed = 0;
            
            for (let i = 0; i < 20; i++) {
                const sentenceInputs = document.querySelectorAll(`[data-sentence="${i}"]`);
                const filledInputs = Array.from(sentenceInputs).filter(input => input.value !== '');
                if (filledInputs.length === 5) {
                    completed++;
                }
            }
            
            const progressPercent = (completed / 20) * 100;
            document.getElementById('progress-bar').style.width = progressPercent + '%';
        }
        
        function completeTrial() {
            clearInterval(timerInterval);
            
            // Collect responses
            responses = [];
            for (let i = 0; i < 20; i++) {
                const sentenceInputs = document.querySelectorAll(`[data-sentence="${i}"]`);
                const sentenceResponse = {
                    sentence: i + 1,
                    words: [],
                    completionTime: Date.now() - startTime
                };
                
                sentenceInputs.forEach(input => {
                    if (input.value !== '') {
                        sentenceResponse.words.push({
                            word: input.dataset.word,
                            position: parseInt(input.value),
                            originalPosition: parseInt(input.dataset.position)
                        });
                    }
                });
                
                // Sort by position to get the final sentence
                sentenceResponse.words.sort((a, b) => a.position - b.position);
                sentenceResponse.finalSentence = sentenceResponse.words.map(w => w.word).join(' ');
                
                responses.push(sentenceResponse);
            }
            
            document.getElementById('main-task').classList.add('hidden');
            document.getElementById('digit-recall').classList.remove('hidden');
        }
        
        function completeTask() {
            const recalledDigits = document.getElementById('recalled-digits').value;
            const digitAccuracy = recalledDigits === currentDigits;
            
            // Calculate valence scores
            const valenceAnalysis = calculateValenceScores(responses);
            
            // Store final results
            const finalResults = {
                responses: responses,
                cognitiveLoad: {
                    originalDigits: currentDigits,
                    recalledDigits: recalledDigits,
                    accuracy: digitAccuracy
                },
                totalTime: Date.now() - startTime,
                valenceAnalysis: valenceAnalysis
            };
            
            // Display results (in practice, this would be sent to Qualtrics)
            document.getElementById('digit-recall').classList.add('hidden');
            document.getElementById('completion').classList.remove('hidden');
            
            document.getElementById('results').innerHTML = `
                <h3>Task Summary</h3>
                <p>Sentences completed: ${valenceAnalysis.summary.completedSentences}/20</p>
                <p>Memory accuracy: ${digitAccuracy ? 'Correct' : 'Incorrect'}</p>
                <p>Total time: ${Math.round(finalResults.totalTime / 1000)} seconds</p>
                <h4>Valence Analysis</h4>
                <p>Positive responses: ${valenceAnalysis.summary.positiveCount} (${Math.round(valenceAnalysis.summary.valenceRatio * 100)}%)</p>
                <p>Negative responses: ${valenceAnalysis.summary.negativeCount} (${Math.round(valenceAnalysis.summary.negativityRatio * 100)}%)</p>
                <p>Neutral/Mixed: ${valenceAnalysis.summary.neutralCount + valenceAnalysis.summary.mixedCount}</p>
                <textarea readonly style="width: 100%; height: 300px; font-family: monospace; font-size: 12px;">${JSON.stringify(finalResults, null, 2)}</textarea>
            `;
            
            // In Qualtrics, you would use:
            // Qualtrics.SurveyEngine.setEmbeddedData('scrambledSentenceResults', JSON.stringify(finalResults));
        }
        
        // Initialize the task
        window.onload = function() {
            setTimeout(showCognitiveLoad, 1000); // Start after 1 second
        };
    </script>
</body>
</html>